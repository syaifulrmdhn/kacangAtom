(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module.exports = function() {
    var DEFINITIONS, VARIABLE_PATTERN, VARIABLE_TYPES, path;
    path = require('path');
    VARIABLE_PATTERN = '\\{{ VARIABLE }}[\\s]*[:=][\\s]*([^\\;\\n]+)[\\;|\\n]';
    VARIABLE_TYPES = [
      {
        type: 'sass',
        extensions: ['.scss', '.sass'],
        regExp: /([\$])([\w0-9-_]+)/i
      }, {
        type: 'less',
        extensions: ['.less'],
        regExp: /([\@])([\w0-9-_]+)/i
      }, {
        type: 'stylus',
        extensions: ['.stylus', '.styl'],
        regExp: /([\$])([\w0-9-_]+)/i
      }
    ];
    DEFINITIONS = {};
    return {
      find: function(string, pathName) {
        var SmartVariable, _match, _matches, _variables, extensions, fn, j, k, len, len1, ref, ref1, regExp, type;
        SmartVariable = this;
        _variables = [];
        for (j = 0, len = VARIABLE_TYPES.length; j < len; j++) {
          ref = VARIABLE_TYPES[j], type = ref.type, extensions = ref.extensions, regExp = ref.regExp;
          _matches = string.match(new RegExp(regExp.source, 'ig'));
          if (!_matches) {
            continue;
          }
          if (pathName) {
            if (ref1 = path.extname(pathName), indexOf.call(extensions, ref1) < 0) {
              continue;
            }
          }
          fn = function(type, extensions, _match) {
            var _index;
            if ((_index = string.indexOf(_match)) === -1) {
              return;
            }
            _variables.push({
              match: _match,
              type: type,
              extensions: extensions,
              start: _index,
              end: _index + _match.length,
              getDefinition: function() {
                return SmartVariable.getDefinition(this);
              },
              isVariable: true
            });
            return string = string.replace(_match, (new Array(_match.length + 1)).join(' '));
          };
          for (k = 0, len1 = _matches.length; k < len1; k++) {
            _match = _matches[k];
            fn(type, extensions, _match);
          }
        }
        return _variables;
      },
      getDefinition: function(variable, initial) {
        var _definition, _options, _pointer, _regExp, _results, extensions, match, type;
        match = variable.match, type = variable.type, extensions = variable.extensions;
        _regExp = new RegExp(VARIABLE_PATTERN.replace('{{ VARIABLE }}', match));
        if (_definition = DEFINITIONS[match]) {
          if (initial == null) {
            initial = _definition;
          }
          _pointer = _definition.pointer;
          return atom.project.bufferForPath(_pointer.filePath).then((function(_this) {
            return function(buffer) {
              var _found, _match, _text;
              _text = buffer.getTextInRange(_pointer.range);
              _match = _text.match(_regExp);
              if (!_match) {
                DEFINITIONS[match] = null;
                return _this.getDefinition(variable, initial);
              }
              _definition.value = _match[1];
              _found = (_this.find(_match[1], _pointer.filePath))[0];
              if (_found && _found.isVariable) {
                return _this.getDefinition(_found, initial);
              }
              return {
                value: _definition.value,
                variable: _definition.variable,
                type: _definition.type,
                pointer: initial.pointer
              };
            };
          })(this))["catch"]((function(_this) {
            return function(error) {
              return console.error(error);
            };
          })(this));
        }
        _options = {
          paths: (function() {
            var _extension, j, len, results;
            results = [];
            for (j = 0, len = extensions.length; j < len; j++) {
              _extension = extensions[j];
              results.push("**/*" + _extension);
            }
            return results;
          })()
        };
        _results = [];
        return atom.workspace.scan(_regExp, _options, function(result) {
          return _results.push(result);
        }).then((function(_this) {
          return function() {
            var _bestMatch, _bestMatchHits, _match, _pathFragments, _targetFragments, _targetPath, _thisMatchHits, i, j, k, len, len1, pathFragment, result;
            _targetPath = atom.workspace.getActivePaneItem().getPath();
            _targetFragments = _targetPath.split(path.sep);
            _bestMatch = null;
            _bestMatchHits = 0;
            for (j = 0, len = _results.length; j < len; j++) {
              result = _results[j];
              _thisMatchHits = 0;
              _pathFragments = result.filePath.split(path.sep);
              for (i = k = 0, len1 = _pathFragments.length; k < len1; i = ++k) {
                pathFragment = _pathFragments[i];
                if (pathFragment === _targetFragments[i]) {
                  _thisMatchHits++;
                }
              }
              if (_thisMatchHits > _bestMatchHits) {
                _bestMatch = result;
                _bestMatchHits = _thisMatchHits;
              }
            }
            if (!(_bestMatch && (_match = _bestMatch.matches[0]))) {
              return;
            }
            DEFINITIONS[match] = {
              value: null,
              variable: match,
              type: type,
              pointer: {
                filePath: _bestMatch.filePath,
                range: _match.range
              }
            };
            if (initial == null) {
              initial = DEFINITIONS[match];
            }
            return _this.getDefinition(variable, initial);
          };
        })(this))["catch"]((function(_this) {
          return function(error) {
            return console.error(error);
          };
        })(this));
      }
    };
  };

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL2hvbWUvc3lhaWYvLmF0b20vcGFja2FnZXMvY29sb3ItcGlja2VyL2xpYi9tb2R1bGVzL1NtYXJ0VmFyaWFibGUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlJO0FBQUEsTUFBQTs7RUFBQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFBO0FBQ2IsUUFBQTtJQUFBLElBQUEsR0FBTyxPQUFBLENBQVEsTUFBUjtJQUtQLGdCQUFBLEdBQW1CO0lBRW5CLGNBQUEsR0FBaUI7TUFHYjtRQUNJLElBQUEsRUFBTSxNQURWO1FBRUksVUFBQSxFQUFZLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FGaEI7UUFHSSxNQUFBLEVBQVEscUJBSFo7T0FIYSxFQVdiO1FBQ0ksSUFBQSxFQUFNLE1BRFY7UUFFSSxVQUFBLEVBQVksQ0FBQyxPQUFELENBRmhCO1FBR0ksTUFBQSxFQUFRLHFCQUhaO09BWGEsRUFtQmI7UUFDSSxJQUFBLEVBQU0sUUFEVjtRQUVJLFVBQUEsRUFBWSxDQUFDLFNBQUQsRUFBWSxPQUFaLENBRmhCO1FBR0ksTUFBQSxFQUFRLHFCQUhaO09BbkJhOztJQTZCakIsV0FBQSxHQUFjO0FBS2QsV0FBTztNQU9ILElBQUEsRUFBTSxTQUFDLE1BQUQsRUFBUyxRQUFUO0FBQ0YsWUFBQTtRQUFBLGFBQUEsR0FBZ0I7UUFDaEIsVUFBQSxHQUFhO0FBRWIsYUFBQSxnREFBQTttQ0FBSyxpQkFBTSw2QkFBWTtVQUNuQixRQUFBLEdBQVcsTUFBTSxDQUFDLEtBQVAsQ0FBa0IsSUFBQSxNQUFBLENBQU8sTUFBTSxDQUFDLE1BQWQsRUFBc0IsSUFBdEIsQ0FBbEI7VUFDWCxJQUFBLENBQWdCLFFBQWhCO0FBQUEscUJBQUE7O1VBR0EsSUFBRyxRQUFIO1lBQ0ksV0FBaUIsSUFBSSxDQUFDLE9BQUwsQ0FBYSxRQUFiLENBQUQsRUFBQSxhQUEyQixVQUEzQixFQUFBLElBQUEsS0FBaEI7QUFBQSx1QkFBQTthQURK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LEtBQUMsQ0FBQSxhQUFELENBQWUsUUFBZixFQUF5QixPQUF6QjtVQWpDTDtRQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FGQyxDQW9DUCxFQUFDLEtBQUQsRUFwQ08sQ0FvQ0EsQ0FBQSxTQUFBLEtBQUE7aUJBQUEsU0FBQyxLQUFEO21CQUFXLE9BQU8sQ0FBQyxLQUFSLENBQWMsS0FBZDtVQUFYO1FBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQXBDQTtNQWxESSxDQTlDWjs7RUExQ007QUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiMgIFNtYXJ0VmFyaWFibGVcbiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAtPlxuICAgICAgICBwYXRoID0gcmVxdWlyZSAncGF0aCdcblxuICAgICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICMgIFZhcmlhYmxlIFR5cGVzXG4gICAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFZBUklBQkxFX1BBVFRFUk4gPSAnXFxcXHt7IFZBUklBQkxFIH19W1xcXFxzXSpbOj1dW1xcXFxzXSooW15cXFxcO1xcXFxuXSspW1xcXFw7fFxcXFxuXSdcblxuICAgICAgICBWQVJJQUJMRV9UWVBFUyA9IFtcbiAgICAgICAgICAgICMgTWF0Y2hlcyBTYXNzIHZhcmlhYmxlOiBlZy5cbiAgICAgICAgICAgICMgJGNvbG9yLXZhclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzYXNzJ1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IFsnLnNjc3MnLCAnLnNhc3MnXVxuICAgICAgICAgICAgICAgIHJlZ0V4cDogLyhbXFwkXSkoW1xcdzAtOS1fXSspL2lcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIyBNYXRjaGVzIExFU1MgdmFyaWFibGU6IGVnLlxuICAgICAgICAgICAgIyBAY29sb3ItdmFyXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xlc3MnXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogWycubGVzcyddXG4gICAgICAgICAgICAgICAgcmVnRXhwOiAvKFtcXEBdKShbXFx3MC05LV9dKykvaVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAjIE1hdGNoZXMgU3R5bHVzIHZhcmlhYmxlOiBlZy5cbiAgICAgICAgICAgICMgJGNvbG9yLXZhclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHlsdXMnXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogWycuc3R5bHVzJywgJy5zdHlsJ11cbiAgICAgICAgICAgICAgICByZWdFeHA6IC8oW1xcJF0pKFtcXHcwLTktX10rKS9pXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cblxuICAgICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICMgIERlZmluaXRpb24gc3RvcmFnZVxuICAgICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBERUZJTklUSU9OUyA9IHt9XG5cbiAgICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAjICBQdWJsaWMgZnVuY3Rpb25hbGl0eVxuICAgICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIyAgRmluZCB2YXJpYWJsZXMgaW4gc3RyaW5nXG4gICAgICAgICMgIC0gc3RyaW5nIHtTdHJpbmd9XG4gICAgICAgICNcbiAgICAgICAgIyAgQHJldHVybiBTdHJpbmdcbiAgICAgICAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmaW5kOiAoc3RyaW5nLCBwYXRoTmFtZSkgLT5cbiAgICAgICAgICAgICAgICBTbWFydFZhcmlhYmxlID0gdGhpc1xuICAgICAgICAgICAgICAgIF92YXJpYWJsZXMgPSBbXVxuXG4gICAgICAgICAgICAgICAgZm9yIHt0eXBlLCBleHRlbnNpb25zLCByZWdFeHB9IGluIFZBUklBQkxFX1RZUEVTXG4gICAgICAgICAgICAgICAgICAgIF9tYXRjaGVzID0gc3RyaW5nLm1hdGNoIChuZXcgUmVnRXhwIHJlZ0V4cC5zb3VyY2UsICdpZycpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHVubGVzcyBfbWF0Y2hlc1xuXG4gICAgICAgICAgICAgICAgICAgICMgTWFrZSBzdXJlIHRoZSBmaWxlIHR5cGUgbWF0Y2hlcyBwb3NzaWJsZSBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIHBhdGhOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSB1bmxlc3MgKHBhdGguZXh0bmFtZSBwYXRoTmFtZSkgaW4gZXh0ZW5zaW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciBfbWF0Y2ggaW4gX21hdGNoZXMgdGhlbiBkbyAodHlwZSwgZXh0ZW5zaW9ucywgX21hdGNoKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlmIChfaW5kZXggPSBzdHJpbmcuaW5kZXhPZiBfbWF0Y2gpIGlzIC0xXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF92YXJpYWJsZXMucHVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBfbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBfaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IF9pbmRleCArIF9tYXRjaC5sZW5ndGhcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldERlZmluaXRpb246IC0+IFNtYXJ0VmFyaWFibGUuZ2V0RGVmaW5pdGlvbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYXJpYWJsZTogdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAjIFJlbW92ZSB0aGUgbWF0Y2ggZnJvbSB0aGUgbGluZSBjb250ZW50IHN0cmluZyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgIyDigJxtYXJrIGl04oCdIGFzIGhhdmluZyBiZWVuIOKAnHNwZW504oCdLiBCZSBjYXJlZnVsIHRvIGtlZXAgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGNvcnJlY3QgYW1vdW50IG9mIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcyB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGxhdGVyIHVzZWQgdG8gc2VlIHdoaWNoIG1hdGNoIGZpdHMgYmVzdCwgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSBfbWF0Y2gsIChuZXcgQXJyYXkgX21hdGNoLmxlbmd0aCArIDEpLmpvaW4gJyAnXG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJpYWJsZXNcblxuICAgICAgICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIyAgRmluZCBhIHZhcmlhYmxlIGRlZmluaXRpb24gaW4gdGhlIHByb2plY3RcbiAgICAgICAgIyAgLSBuYW1lIHtTdHJpbmd9XG4gICAgICAgICMgIC0gdHlwZSB7U3RyaW5nfVxuICAgICAgICAjXG4gICAgICAgICMgIEByZXR1cm4gUHJvbWlzZVxuICAgICAgICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGdldERlZmluaXRpb246ICh2YXJpYWJsZSwgaW5pdGlhbCkgLT5cbiAgICAgICAgICAgICAgICB7bWF0Y2gsIHR5cGUsIGV4dGVuc2lvbnN9ID0gdmFyaWFibGVcblxuICAgICAgICAgICAgICAgICMgRmlndXJlIG91dCB3aGF0IHRvIGxvb2sgZm9yXG4gICAgICAgICAgICAgICAgX3JlZ0V4cCA9IG5ldyBSZWdFeHAgKFZBUklBQkxFX1BBVFRFUk4ucmVwbGFjZSAne3sgVkFSSUFCTEUgfX0nLCBtYXRjaClcblxuICAgICAgICAgICAgICAgICMgV2UgYWxyZWFkeSBrbm93IHdoZXJlIHRoZSBkZWZpbml0aW9uIGlzXG4gICAgICAgICAgICAgICAgaWYgX2RlZmluaXRpb24gPSBERUZJTklUSU9OU1ttYXRjaF1cbiAgICAgICAgICAgICAgICAgICAgIyBTYXZlIGluaXRpYWwgcG9pbnRlciB2YWx1ZSwgaWYgaXQgaXNuJ3Qgc2V0IGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbCA/PSBfZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICBfcG9pbnRlciA9IF9kZWZpbml0aW9uLnBvaW50ZXJcblxuICAgICAgICAgICAgICAgICAgICAjIC4uLiBidXQgY2hlY2sgaWYgaXQncyBzdGlsbCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXRvbS5wcm9qZWN0LmJ1ZmZlckZvclBhdGggX3BvaW50ZXIuZmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuIChidWZmZXIpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RleHQgPSBidWZmZXIuZ2V0VGV4dEluUmFuZ2UgX3BvaW50ZXIucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWF0Y2ggPSBfdGV4dC5tYXRjaCBfcmVnRXhwXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIERlZmluaXRpb24gbm90IGZvdW5kLCByZXNldCBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5sZXNzIF9tYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBERUZJTklUSU9OU1ttYXRjaF0gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBAZ2V0RGVmaW5pdGlvbiB2YXJpYWJsZSwgaW5pdGlhbFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBEZWZpbml0aW9uIGZvdW5kLCBzYXZlIGl0IG9uIHRoZSBERUZJTklUSU9OIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWZpbml0aW9uLnZhbHVlID0gX21hdGNoWzFdXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIC4uLiBidXQgaXQgbWlnaHQgYmUgYW5vdGhlciB2YXJpYWJsZSwgaW4gd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGNhc2Ugd2UgbXVzdCBrZWVwIGRpZ2dpbmcgdG8gZmluZCB3aGF0IHdlJ3JlIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZvdW5kID0gKEBmaW5kIF9tYXRjaFsxXSwgX3BvaW50ZXIuZmlsZVBhdGgpWzBdXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIFJ1biB0aGUgc2VhcmNoIGFnYWluLCBidXQga2VlcCB0aGUgaW5pdGlhbCBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgX2ZvdW5kIGFuZCBfZm91bmQuaXNWYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQGdldERlZmluaXRpb24gX2ZvdW5kLCBpbml0aWFsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZmluaXRpb24udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IF9kZWZpbml0aW9uLnZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9kZWZpbml0aW9uLnR5cGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyOiBpbml0aWFsLnBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2ggKGVycm9yKSA9PiBjb25zb2xlLmVycm9yIGVycm9yXG5cbiAgICAgICAgICAgICAgICAjIC4uLiB3ZSBkb24ndCBrbm93IHdoZXJlIHRoZSBkZWZpbml0aW9uIGlzXG5cbiAgICAgICAgICAgICAgICAjIEZpZ3VyZSBvdXQgd2hlcmUgdG8gbG9va1xuICAgICAgICAgICAgICAgIF9vcHRpb25zID0gcGF0aHM6IGRvIC0+XG4gICAgICAgICAgICAgICAgICAgIFwiKiovKiN7IF9leHRlbnNpb24gfVwiIGZvciBfZXh0ZW5zaW9uIGluIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICBfcmVzdWx0cyA9IFtdXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXRvbS53b3Jrc3BhY2Uuc2NhbiBfcmVnRXhwLCBfb3B0aW9ucywgKHJlc3VsdCkgLT5cbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCByZXN1bHRcbiAgICAgICAgICAgICAgICAudGhlbiA9PlxuICAgICAgICAgICAgICAgICAgICAjIEZpZ3VyZSBvdXQgd2hhdCBmaWxlIGlzIGhvbGRpbmcgdGhlIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgIyBBc3N1bWUgaXQncyB0aGUgb25lIGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0UGF0aCA9IGF0b20ud29ya3NwYWNlLmdldEFjdGl2ZVBhbmVJdGVtKCkuZ2V0UGF0aCgpXG4gICAgICAgICAgICAgICAgICAgIF90YXJnZXRGcmFnbWVudHMgPSBfdGFyZ2V0UGF0aC5zcGxpdCBwYXRoLnNlcFxuXG4gICAgICAgICAgICAgICAgICAgIF9iZXN0TWF0Y2ggPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIF9iZXN0TWF0Y2hIaXRzID0gMFxuXG4gICAgICAgICAgICAgICAgICAgIGZvciByZXN1bHQgaW4gX3Jlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzTWF0Y2hIaXRzID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgX3BhdGhGcmFnbWVudHMgPSByZXN1bHQuZmlsZVBhdGguc3BsaXQgcGF0aC5zZXBcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzTWF0Y2hIaXRzKysgZm9yIHBhdGhGcmFnbWVudCwgaSBpbiBfcGF0aEZyYWdtZW50cyB3aGVuIHBhdGhGcmFnbWVudCBpcyBfdGFyZ2V0RnJhZ21lbnRzW2ldXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIF90aGlzTWF0Y2hIaXRzID4gX2Jlc3RNYXRjaEhpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmVzdE1hdGNoID0gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jlc3RNYXRjaEhpdHMgPSBfdGhpc01hdGNoSGl0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5sZXNzIF9iZXN0TWF0Y2ggYW5kIF9tYXRjaCA9IF9iZXN0TWF0Y2gubWF0Y2hlc1swXVxuXG4gICAgICAgICAgICAgICAgICAgICMgU2F2ZSB0aGUgZGVmaW5pdGlvbiBvbiB0aGUgREVGSU5JVElPTiBvYmplY3Qgc28gdGhhdCBpdFxuICAgICAgICAgICAgICAgICAgICAjIGNhbiBiZSBhY2Nlc3NlZCBsYXRlclxuICAgICAgICAgICAgICAgICAgICBERUZJTklUSU9OU1ttYXRjaF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IF9iZXN0TWF0Y2guZmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogX21hdGNoLnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAjIFNhdmUgaW5pdGlhbCBwb2ludGVyIHZhbHVlLCBpZiBpdCBpc24ndCBzZXQgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsID89IERFRklOSVRJT05TW21hdGNoXVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQGdldERlZmluaXRpb24gdmFyaWFibGUsIGluaXRpYWxcbiAgICAgICAgICAgICAgICAuY2F0Y2ggKGVycm9yKSA9PiBjb25zb2xlLmVycm9yIGVycm9yXG4gICAgICAgIH1cbiJdfQ==
